{"version":3,"file":"index.cjs","sources":["../node_modules/quickselect/index.js","../node_modules/rbush/index.js","../node_modules/tinyqueue/index.js","../node_modules/point-in-polygon/index.js","../node_modules/point-in-polygon/flat.js","../node_modules/point-in-polygon/nested.js","../node_modules/robust-predicates/esm/util.js","../node_modules/robust-predicates/esm/orient2d.js","../index.mjs"],"sourcesContent":["\nexport default function quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","import quickselect from 'quickselect';\n\nexport default class RBush {\n    constructor(maxEntries = 9) {\n        // max entries in a node is 9 by default; min node fill is 40% for best performance\n        this._maxEntries = Math.max(4, maxEntries);\n        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n        this.clear();\n    }\n\n    all() {\n        return this._all(this.data, []);\n    }\n\n    search(bbox) {\n        let node = this.data;\n        const result = [];\n\n        if (!intersects(bbox, node)) return result;\n\n        const toBBox = this.toBBox;\n        const nodesToSearch = [];\n\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    }\n\n    collides(bbox) {\n        let node = this.data;\n\n        if (!intersects(bbox, node)) return false;\n\n        const nodesToSearch = [];\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? this.toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    }\n\n    load(data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (let i = 0; i < data.length; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        let node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                const tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    }\n\n    insert(item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    }\n\n    clear() {\n        this.data = createNode([]);\n        return this;\n    }\n\n    remove(item, equalsFn) {\n        if (!item) return this;\n\n        let node = this.data;\n        const bbox = this.toBBox(item);\n        const path = [];\n        const indexes = [];\n        let i, parent, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                const index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    }\n\n    toBBox(item) { return item; }\n\n    compareMinX(a, b) { return a.minX - b.minX; }\n    compareMinY(a, b) { return a.minY - b.minY; }\n\n    toJSON() { return this.data; }\n\n    fromJSON(data) {\n        this.data = data;\n        return this;\n    }\n\n    _all(node, result) {\n        const nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push(...node.children);\n            else nodesToSearch.push(...node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    }\n\n    _build(items, left, right, height) {\n\n        const N = right - left + 1;\n        let M = this._maxEntries;\n        let node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        const N2 = Math.ceil(N / M);\n        const N1 = N2 * Math.ceil(Math.sqrt(M));\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (let i = left; i <= right; i += N1) {\n\n            const right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (let j = i; j <= right2; j += N2) {\n\n                const right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    }\n\n    _chooseSubtree(bbox, node, level, path) {\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            let minArea = Infinity;\n            let minEnlargement = Infinity;\n            let targetNode;\n\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const area = bboxArea(child);\n                const enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    }\n\n    _insert(item, level, isNode) {\n        const bbox = isNode ? item : this.toBBox(item);\n        const insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        const node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    }\n\n    // split overflowed node into two\n    _split(insertPath, level) {\n        const node = insertPath[level];\n        const M = node.children.length;\n        const m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        const splitIndex = this._chooseSplitIndex(node, m, M);\n\n        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    }\n\n    _splitRoot(node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    }\n\n    _chooseSplitIndex(node, m, M) {\n        let index;\n        let minOverlap = Infinity;\n        let minArea = Infinity;\n\n        for (let i = m; i <= M - m; i++) {\n            const bbox1 = distBBox(node, 0, i, this.toBBox);\n            const bbox2 = distBBox(node, i, M, this.toBBox);\n\n            const overlap = intersectionArea(bbox1, bbox2);\n            const area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index || M - m;\n    }\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis(node, m, M) {\n        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n        const xMargin = this._allDistMargin(node, m, M, compareMinX);\n        const yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    }\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin(node, m, M, compare) {\n        node.children.sort(compare);\n\n        const toBBox = this.toBBox;\n        const leftBBox = distBBox(node, 0, m, toBBox);\n        const rightBBox = distBBox(node, M - m, M, toBBox);\n        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n        for (let i = m; i < M - m; i++) {\n            const child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (let i = M - m - 1; i >= m; i--) {\n            const child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    }\n\n    _adjustParentBBoxes(bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (let i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    }\n\n    _condense(path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (let i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    }\n}\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (let i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (let i = k; i < p; i++) {\n        const child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    const minX = Math.max(a.minX, b.minX);\n    const minY = Math.max(a.minY, b.minY);\n    const maxX = Math.min(a.maxX, b.maxX);\n    const maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    const stack = [left, right];\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        const mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","\nexport default class TinyQueue {\n    constructor(data = [], compare = defaultCompare) {\n        this.data = data;\n        this.length = this.data.length;\n        this.compare = compare;\n\n        if (this.length > 0) {\n            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n        }\n    }\n\n    push(item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    }\n\n    pop() {\n        if (this.length === 0) return undefined;\n\n        const top = this.data[0];\n        const bottom = this.data.pop();\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = bottom;\n            this._down(0);\n        }\n\n        return top;\n    }\n\n    peek() {\n        return this.data[0];\n    }\n\n    _up(pos) {\n        const {data, compare} = this;\n        const item = data[pos];\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    }\n\n    _down(pos) {\n        const {data, compare} = this;\n        const halfLength = this.length >> 1;\n        const item = data[pos];\n\n        while (pos < halfLength) {\n            let left = (pos << 1) + 1;\n            let best = data[left];\n            const right = left + 1;\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","var pointInPolygonFlat = require('./flat.js')\nvar pointInPolygonNested = require('./nested.js')\n\nmodule.exports = function pointInPolygon (point, vs, start, end) {\n    if (vs.length > 0 && Array.isArray(vs[0])) {\n        return pointInPolygonNested(point, vs, start, end);\n    } else {\n        return pointInPolygonFlat(point, vs, start, end);\n    }\n}\nmodule.exports.nested = pointInPolygonNested\nmodule.exports.flat = pointInPolygonFlat\n","module.exports = function pointInPolygonFlat (point, vs, start, end) {\n    var x = point[0], y = point[1];\n    var inside = false;\n    if (start === undefined) start = 0;\n    if (end === undefined) end = vs.length;\n    var len = (end-start)/2;\n    for (var i = 0, j = len - 1; i < len; j = i++) {\n        var xi = vs[start+i*2+0], yi = vs[start+i*2+1];\n        var xj = vs[start+j*2+0], yj = vs[start+j*2+1];\n        var intersect = ((yi > y) !== (yj > y))\n            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n        if (intersect) inside = !inside;\n    }\n    return inside;\n};\n","// ray-casting algorithm based on\n// https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html\n\nmodule.exports = function pointInPolygonNested (point, vs, start, end) {\n    var x = point[0], y = point[1];\n    var inside = false;\n    if (start === undefined) start = 0;\n    if (end === undefined) end = vs.length;\n    var len = end - start;\n    for (var i = 0, j = len - 1; i < len; j = i++) {\n        var xi = vs[i+start][0], yi = vs[i+start][1];\n        var xj = vs[j+start][0], yj = vs[j+start][1];\n        var intersect = ((yi > y) !== (yj > y))\n            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n        if (intersect) inside = !inside;\n    }\n    return inside;\n};\n","export const epsilon = 1.1102230246251565e-16;\nexport const splitter = 134217729;\nexport const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n// fast_expansion_sum_zeroelim routine from oritinal code\nexport function sum(elen, e, flen, f, h) {\n    let Q, Qnew, hh, bvirt;\n    let enow = e[0];\n    let fnow = f[0];\n    let eindex = 0;\n    let findex = 0;\n    if ((fnow > enow) === (fnow > -enow)) {\n        Q = enow;\n        enow = e[++eindex];\n    } else {\n        Q = fnow;\n        fnow = f[++findex];\n    }\n    let hindex = 0;\n    if (eindex < elen && findex < flen) {\n        if ((fnow > enow) === (fnow > -enow)) {\n            Qnew = enow + Q;\n            hh = Q - (Qnew - enow);\n            enow = e[++eindex];\n        } else {\n            Qnew = fnow + Q;\n            hh = Q - (Qnew - fnow);\n            fnow = f[++findex];\n        }\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        while (eindex < elen && findex < flen) {\n            if ((fnow > enow) === (fnow > -enow)) {\n                Qnew = Q + enow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (enow - bvirt);\n                enow = e[++eindex];\n            } else {\n                Qnew = Q + fnow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n                fnow = f[++findex];\n            }\n            Q = Qnew;\n            if (hh !== 0) {\n                h[hindex++] = hh;\n            }\n        }\n    }\n    while (eindex < elen) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    while (findex < flen) {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function sum_three(alen, a, blen, b, clen, c, tmp, out) {\n    return sum(sum(alen, a, blen, b, tmp), tmp, clen, c, out);\n}\n\n// scale_expansion_zeroelim routine from oritinal code\nexport function scale(elen, e, b, h) {\n    let Q, sum, hh, product1, product0;\n    let bvirt, c, ahi, alo, bhi, blo;\n\n    c = splitter * b;\n    bhi = c - (c - b);\n    blo = b - bhi;\n    let enow = e[0];\n    Q = enow * b;\n    c = splitter * enow;\n    ahi = c - (c - enow);\n    alo = enow - ahi;\n    hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);\n    let hindex = 0;\n    if (hh !== 0) {\n        h[hindex++] = hh;\n    }\n    for (let i = 1; i < elen; i++) {\n        enow = e[i];\n        product1 = enow * b;\n        c = splitter * enow;\n        ahi = c - (c - enow);\n        alo = enow - ahi;\n        product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);\n        sum = Q + product0;\n        bvirt = sum - Q;\n        hh = Q - (sum - bvirt) + (product0 - bvirt);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        Q = product1 + sum;\n        hh = sum - (Q - product1);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function negate(elen, e) {\n    for (let i = 0; i < elen; i++) e[i] = -e[i];\n    return elen;\n}\n\nexport function estimate(elen, e) {\n    let Q = e[0];\n    for (let i = 1; i < elen; i++) Q += e[i];\n    return Q;\n}\n\nexport function vec(n) {\n    return new Float64Array(n);\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum} from './util.js';\n\nconst ccwerrboundA = (3 + 16 * epsilon) * epsilon;\nconst ccwerrboundB = (2 + 12 * epsilon) * epsilon;\nconst ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n\nconst B = vec(4);\nconst C1 = vec(8);\nconst C2 = vec(12);\nconst D = vec(16);\nconst u = vec(4);\n\nfunction orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n    let acxtail, acytail, bcxtail, bcytail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    const acx = ax - cx;\n    const bcx = bx - cx;\n    const acy = ay - cy;\n    const bcy = by - cy;\n\n    s1 = acx * bcy;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcx;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    B[3] = u3;\n\n    let det = estimate(4, B);\n    let errbound = ccwerrboundB * detsum;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - acx;\n    acxtail = ax - (acx + bvirt) + (bvirt - cx);\n    bvirt = bx - bcx;\n    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n    bvirt = ay - acy;\n    acytail = ay - (acy + bvirt) + (bvirt - cy);\n    bvirt = by - bcy;\n    bcytail = by - (bcy + bvirt) + (bvirt - cy);\n\n    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n        return det;\n    }\n\n    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\n    if (det >= errbound || -det >= errbound) return det;\n\n    s1 = acxtail * bcy;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcx;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C1len = sum(4, B, 4, u, C1);\n\n    s1 = acx * bcytail;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcxtail;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C2len = sum(C1len, C1, 4, u, C2);\n\n    s1 = acxtail * bcytail;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcxtail;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const Dlen = sum(C2len, C2, 4, u, D);\n\n    return D[Dlen - 1];\n}\n\nexport function orient2d(ax, ay, bx, by, cx, cy) {\n    const detleft = (ay - cy) * (bx - cx);\n    const detright = (ax - cx) * (by - cy);\n    const det = detleft - detright;\n\n    const detsum = Math.abs(detleft + detright);\n    if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n\n    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n}\n\nexport function orient2dfast(ax, ay, bx, by, cx, cy) {\n    return (ay - cy) * (bx - cx) - (ax - cx) * (by - cy);\n}\n","import RBush from \"rbush\";\nimport Queue from \"tinyqueue\";\nimport pointInPolygon from \"point-in-polygon\";\nimport { orient2d as orient } from \"robust-predicates\";\n\nconst concaveman = (points, concavity, lengthThreshold) => {\n  // a relative measure of concavity; higher value means simpler hull\n  concavity = Math.max(0, concavity === undefined ? 2 : concavity);\n\n  // when a segment goes below this length threshold, it won't be drilled down further\n  lengthThreshold = lengthThreshold || 0;\n\n  // start with a convex hull of the points\n  var hull = fastConvexHull(points);\n\n  // index the points with an R-tree\n  var tree = new RBush(16);\n  tree.toBBox = function (a) {\n    return {\n      minX: a[0],\n      minY: a[1],\n      maxX: a[0],\n      maxY: a[1],\n    };\n  };\n  tree.compareMinX = function (a, b) {\n    return a[0] - b[0];\n  };\n  tree.compareMinY = function (a, b) {\n    return a[1] - b[1];\n  };\n\n  tree.load(points);\n\n  // turn the convex hull into a linked list and populate the initial edge queue with the nodes\n  var queue = [];\n  for (var i = 0, last; i < hull.length; i++) {\n    var p = hull[i];\n    tree.remove(p);\n    last = insertNode(p, last);\n    queue.push(last);\n  }\n\n  // index the segments with an R-tree (for intersection checks)\n  var segTree = new RBush(16);\n  for (i = 0; i < queue.length; i++) segTree.insert(updateBBox(queue[i]));\n\n  var sqConcavity = concavity * concavity;\n  var sqLenThreshold = lengthThreshold * lengthThreshold;\n\n  // process edges one by one\n  while (queue.length) {\n    var node = queue.shift();\n    var a = node.p;\n    var b = node.next.p;\n\n    // skip the edge if it's already short enough\n    var sqLen = getSqDist(a, b);\n    if (sqLen < sqLenThreshold) continue;\n\n    var maxSqLen = sqLen / sqConcavity;\n\n    // find the best connection point for the current edge to flex inward to\n    p = findCandidate(\n      tree,\n      node.prev.p,\n      a,\n      b,\n      node.next.next.p,\n      maxSqLen,\n      segTree\n    );\n\n    // if we found a connection and it satisfies our concavity measure\n    if (p && Math.min(getSqDist(p, a), getSqDist(p, b)) <= maxSqLen) {\n      // connect the edge endpoints through this point and add 2 new edges to the queue\n      queue.push(node);\n      queue.push(insertNode(p, node));\n\n      // update point and segment indexes\n      tree.remove(p);\n      segTree.remove(node);\n      segTree.insert(updateBBox(node));\n      segTree.insert(updateBBox(node.next));\n    }\n  }\n\n  // convert the resulting hull linked list to an array of points\n  node = last;\n  var concave = [];\n  do {\n    concave.push(node.p);\n    node = node.next;\n  } while (node !== last);\n\n  concave.push(node.p);\n\n  return concave;\n};\n\nfunction findCandidate(tree, a, b, c, d, maxDist, segTree) {\n  var queue = new Queue([], compareDist);\n  var node = tree.data;\n\n  // search through the point R-tree with a depth-first search using a priority queue\n  // in the order of distance to the edge (b, c)\n  while (node) {\n    for (var i = 0; i < node.children.length; i++) {\n      var child = node.children[i];\n\n      var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);\n      if (dist > maxDist) continue; // skip the node if it's farther than we ever need\n\n      queue.push({\n        node: child,\n        dist: dist,\n      });\n    }\n\n    while (queue.length && !queue.peek().node.children) {\n      var item = queue.pop();\n      var p = item.node;\n\n      // skip all points that are as close to adjacent edges (a,b) and (c,d),\n      // and points that would introduce self-intersections when connected\n      var d0 = sqSegDist(p, a, b);\n      var d1 = sqSegDist(p, c, d);\n      if (\n        item.dist < d0 &&\n        item.dist < d1 &&\n        noIntersections(b, p, segTree) &&\n        noIntersections(c, p, segTree)\n      )\n        return p;\n    }\n\n    node = queue.pop();\n    if (node) node = node.node;\n  }\n\n  return null;\n}\n\nfunction compareDist(a, b) {\n  return a.dist - b.dist;\n}\n\n// square distance from a segment bounding box to the given one\nfunction sqSegBoxDist(a, b, bbox) {\n  if (inside(a, bbox) || inside(b, bbox)) return 0;\n  var d1 = sqSegSegDist(\n    a[0],\n    a[1],\n    b[0],\n    b[1],\n    bbox.minX,\n    bbox.minY,\n    bbox.maxX,\n    bbox.minY\n  );\n  if (d1 === 0) return 0;\n  var d2 = sqSegSegDist(\n    a[0],\n    a[1],\n    b[0],\n    b[1],\n    bbox.minX,\n    bbox.minY,\n    bbox.minX,\n    bbox.maxY\n  );\n  if (d2 === 0) return 0;\n  var d3 = sqSegSegDist(\n    a[0],\n    a[1],\n    b[0],\n    b[1],\n    bbox.maxX,\n    bbox.minY,\n    bbox.maxX,\n    bbox.maxY\n  );\n  if (d3 === 0) return 0;\n  var d4 = sqSegSegDist(\n    a[0],\n    a[1],\n    b[0],\n    b[1],\n    bbox.minX,\n    bbox.maxY,\n    bbox.maxX,\n    bbox.maxY\n  );\n  if (d4 === 0) return 0;\n  return Math.min(d1, d2, d3, d4);\n}\n\nfunction inside(a, bbox) {\n  return (\n    a[0] >= bbox.minX &&\n    a[0] <= bbox.maxX &&\n    a[1] >= bbox.minY &&\n    a[1] <= bbox.maxY\n  );\n}\n\n// check if the edge (a,b) doesn't intersect any other edges\nfunction noIntersections(a, b, segTree) {\n  var minX = Math.min(a[0], b[0]);\n  var minY = Math.min(a[1], b[1]);\n  var maxX = Math.max(a[0], b[0]);\n  var maxY = Math.max(a[1], b[1]);\n\n  var edges = segTree.search({\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY,\n  });\n  for (var i = 0; i < edges.length; i++) {\n    if (intersects(edges[i].p, edges[i].next.p, a, b)) return false;\n  }\n  return true;\n}\n\nfunction cross(p1, p2, p3) {\n  return orient(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);\n}\n\n// check if the edges (p1,q1) and (p2,q2) intersect\nfunction intersects(p1, q1, p2, q2) {\n  return (\n    p1 !== q2 &&\n    q1 !== p2 &&\n    cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 &&\n    cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0\n  );\n}\n\n// update the bounding box of a node's edge\nfunction updateBBox(node) {\n  var p1 = node.p;\n  var p2 = node.next.p;\n  node.minX = Math.min(p1[0], p2[0]);\n  node.minY = Math.min(p1[1], p2[1]);\n  node.maxX = Math.max(p1[0], p2[0]);\n  node.maxY = Math.max(p1[1], p2[1]);\n  return node;\n}\n\n// speed up convex hull by filtering out points inside quadrilateral formed by 4 extreme points\nfunction fastConvexHull(points) {\n  var left = points[0];\n  var top = points[0];\n  var right = points[0];\n  var bottom = points[0];\n\n  // find the leftmost, rightmost, topmost and bottommost points\n  for (var i = 0; i < points.length; i++) {\n    var p = points[i];\n    if (p[0] < left[0]) left = p;\n    if (p[0] > right[0]) right = p;\n    if (p[1] < top[1]) top = p;\n    if (p[1] > bottom[1]) bottom = p;\n  }\n\n  // filter out points that are inside the resulting quadrilateral\n  var cull = [left, top, right, bottom];\n  var filtered = cull.slice();\n  for (i = 0; i < points.length; i++) {\n    if (!pointInPolygon(points[i], cull)) filtered.push(points[i]);\n  }\n\n  // get convex hull around the filtered points\n  return convexHull(filtered);\n}\n\n// create a new node in a doubly linked list\nfunction insertNode(p, prev) {\n  var node = {\n    p: p,\n    prev: null,\n    next: null,\n    minX: 0,\n    minY: 0,\n    maxX: 0,\n    maxY: 0,\n  };\n\n  if (!prev) {\n    node.prev = node;\n    node.next = node;\n  } else {\n    node.next = prev.next;\n    node.prev = prev;\n    prev.next.prev = node;\n    prev.next = node;\n  }\n  return node;\n}\n\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n  var dx = p1[0] - p2[0],\n    dy = p1[1] - p2[1];\n\n  return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction sqSegDist(p, p1, p2) {\n  var x = p1[0],\n    y = p1[1],\n    dx = p2[0] - x,\n    dy = p2[1] - y;\n\n  if (dx !== 0 || dy !== 0) {\n    var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n\n    if (t > 1) {\n      x = p2[0];\n      y = p2[1];\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n\n  dx = p[0] - x;\n  dy = p[1] - y;\n\n  return dx * dx + dy * dy;\n}\n\n// segment to segment distance, ported from http://geomalgorithms.com/a07-_distance.html by Dan Sunday\nfunction sqSegSegDist(x0, y0, x1, y1, x2, y2, x3, y3) {\n  var ux = x1 - x0;\n  var uy = y1 - y0;\n  var vx = x3 - x2;\n  var vy = y3 - y2;\n  var wx = x0 - x2;\n  var wy = y0 - y2;\n  var a = ux * ux + uy * uy;\n  var b = ux * vx + uy * vy;\n  var c = vx * vx + vy * vy;\n  var d = ux * wx + uy * wy;\n  var e = vx * wx + vy * wy;\n  var D = a * c - b * b;\n\n  var sc, sN, tc, tN;\n  var sD = D;\n  var tD = D;\n\n  if (D === 0) {\n    sN = 0;\n    sD = 1;\n    tN = e;\n    tD = c;\n  } else {\n    sN = b * e - c * d;\n    tN = a * e - b * d;\n    if (sN < 0) {\n      sN = 0;\n      tN = e;\n      tD = c;\n    } else if (sN > sD) {\n      sN = sD;\n      tN = e + b;\n      tD = c;\n    }\n  }\n\n  if (tN < 0.0) {\n    tN = 0.0;\n    if (-d < 0.0) sN = 0.0;\n    else if (-d > a) sN = sD;\n    else {\n      sN = -d;\n      sD = a;\n    }\n  } else if (tN > tD) {\n    tN = tD;\n    if (-d + b < 0.0) sN = 0;\n    else if (-d + b > a) sN = sD;\n    else {\n      sN = -d + b;\n      sD = a;\n    }\n  }\n\n  sc = sN === 0 ? 0 : sN / sD;\n  tc = tN === 0 ? 0 : tN / tD;\n\n  var cx = (1 - sc) * x0 + sc * x1;\n  var cy = (1 - sc) * y0 + sc * y1;\n  var cx2 = (1 - tc) * x2 + tc * x3;\n  var cy2 = (1 - tc) * y2 + tc * y3;\n  var dx = cx2 - cx;\n  var dy = cy2 - cy;\n\n  return dx * dx + dy * dy;\n}\n\nfunction compareByX(a, b) {\n  return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];\n}\n\nfunction convexHull(points) {\n  points.sort(compareByX);\n\n  var lower = [];\n  for (var i = 0; i < points.length; i++) {\n    while (\n      lower.length >= 2 &&\n      cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0\n    ) {\n      lower.pop();\n    }\n    lower.push(points[i]);\n  }\n\n  var upper = [];\n  for (var ii = points.length - 1; ii >= 0; ii--) {\n    while (\n      upper.length >= 2 &&\n      cross(upper[upper.length - 2], upper[upper.length - 1], points[ii]) <= 0\n    ) {\n      upper.pop();\n    }\n    upper.push(points[ii]);\n  }\n\n  upper.pop();\n  lower.pop();\n  return lower.concat(upper);\n}\n\nexport { concaveman };\nexport default concaveman;\n"],"names":["quickselect","arr","k","left","right","compare","quickselectStep","length","defaultCompare","n","m","z","Math","log","s","exp","sd","sqrt","max","floor","min","t","i","j","swap","tmp","a","b","RBush","constructor","maxEntries","this","_maxEntries","_minEntries","ceil","clear","all","_all","data","search","bbox","node","result","intersects","toBBox","nodesToSearch","children","child","childBBox","leaf","push","contains","pop","collides","load","insert","_build","slice","height","_splitRoot","tmpNode","_insert","item","createNode","remove","equalsFn","path","indexes","parent","goingUp","index","findItem","splice","_condense","compareMinX","minX","compareMinY","minY","toJSON","fromJSON","items","N","M","calcBBox","pow","N2","N1","multiSelect","right2","right3","_chooseSubtree","level","targetNode","minArea","Infinity","minEnlargement","area","bboxArea","enlargement","maxX","maxY","isNode","insertPath","extend","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","minOverlap","bbox1","distBBox","bbox2","overlap","intersectionArea","compareNodeMinX","compareNodeMinY","_allDistMargin","sort","leftBBox","rightBBox","margin","bboxMargin","siblings","indexOf","p","destNode","stack","mid","TinyQueue","_down","_up","top","bottom","peek","pos","current","halfLength","best","pointInPolygonFlat","point","vs","start","end","x","y","inside","undefined","len","xi","yi","xj","yj","pointInPolygonNested","pointInPolygonModule","exports","Array","isArray","nested","flat","epsilon","splitter","resulterrbound","sum","elen","e","flen","f","h","Q","Qnew","hh","bvirt","enow","fnow","eindex","findex","hindex","vec","Float64Array","ccwerrboundA","ccwerrboundB","ccwerrboundC","B","C1","C2","D","u","concaveman","points","concavity","lengthThreshold","hull","cull","filtered","pointInPolygon","compareByX","lower","cross","upper","ii","concat","convexHull","fastConvexHull","tree","last","queue","insertNode","segTree","updateBBox","sqConcavity","sqLenThreshold","shift","next","sqLen","getSqDist","maxSqLen","findCandidate","prev","concave","c","d","maxDist","Queue","compareDist","dist","sqSegDist","sqSegBoxDist","d0","d1","noIntersections","sqSegSegDist","d2","d3","d4","p1","q1","p2","q2","edges","p3","ax","ay","bx","by","cx","cy","detleft","detright","det","detsum","abs","acxtail","acytail","bcxtail","bcytail","ahi","alo","bhi","blo","_i","_j","_0","s1","s0","t1","t0","u3","acx","bcx","acy","bcy","estimate","errbound","C1len","C2len","Dlen","orient2dadapt","orient","dx","dy","x0","y0","x1","y1","x2","y2","x3","y3","sc","sN","tc","tN","ux","uy","vx","vy","wx","wy","sD","tD"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7]}