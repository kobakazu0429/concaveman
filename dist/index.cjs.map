{"version":3,"file":"index.cjs","sources":["../node_modules/quickselect/index.js","../node_modules/rbush/index.js","../node_modules/tinyqueue/index.js","../node_modules/point-in-polygon/index.js","../node_modules/point-in-polygon/flat.js","../node_modules/point-in-polygon/nested.js","../node_modules/robust-predicates/esm/util.js","../node_modules/robust-predicates/esm/orient2d.js","../index.mjs"],"sourcesContent":["\nexport default function quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","import quickselect from 'quickselect';\n\nexport default class RBush {\n    constructor(maxEntries = 9) {\n        // max entries in a node is 9 by default; min node fill is 40% for best performance\n        this._maxEntries = Math.max(4, maxEntries);\n        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n        this.clear();\n    }\n\n    all() {\n        return this._all(this.data, []);\n    }\n\n    search(bbox) {\n        let node = this.data;\n        const result = [];\n\n        if (!intersects(bbox, node)) return result;\n\n        const toBBox = this.toBBox;\n        const nodesToSearch = [];\n\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    }\n\n    collides(bbox) {\n        let node = this.data;\n\n        if (!intersects(bbox, node)) return false;\n\n        const nodesToSearch = [];\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? this.toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    }\n\n    load(data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (let i = 0; i < data.length; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        let node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                const tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    }\n\n    insert(item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    }\n\n    clear() {\n        this.data = createNode([]);\n        return this;\n    }\n\n    remove(item, equalsFn) {\n        if (!item) return this;\n\n        let node = this.data;\n        const bbox = this.toBBox(item);\n        const path = [];\n        const indexes = [];\n        let i, parent, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                const index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    }\n\n    toBBox(item) { return item; }\n\n    compareMinX(a, b) { return a.minX - b.minX; }\n    compareMinY(a, b) { return a.minY - b.minY; }\n\n    toJSON() { return this.data; }\n\n    fromJSON(data) {\n        this.data = data;\n        return this;\n    }\n\n    _all(node, result) {\n        const nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push(...node.children);\n            else nodesToSearch.push(...node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    }\n\n    _build(items, left, right, height) {\n\n        const N = right - left + 1;\n        let M = this._maxEntries;\n        let node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        const N2 = Math.ceil(N / M);\n        const N1 = N2 * Math.ceil(Math.sqrt(M));\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (let i = left; i <= right; i += N1) {\n\n            const right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (let j = i; j <= right2; j += N2) {\n\n                const right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    }\n\n    _chooseSubtree(bbox, node, level, path) {\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            let minArea = Infinity;\n            let minEnlargement = Infinity;\n            let targetNode;\n\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const area = bboxArea(child);\n                const enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    }\n\n    _insert(item, level, isNode) {\n        const bbox = isNode ? item : this.toBBox(item);\n        const insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        const node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    }\n\n    // split overflowed node into two\n    _split(insertPath, level) {\n        const node = insertPath[level];\n        const M = node.children.length;\n        const m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        const splitIndex = this._chooseSplitIndex(node, m, M);\n\n        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    }\n\n    _splitRoot(node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    }\n\n    _chooseSplitIndex(node, m, M) {\n        let index;\n        let minOverlap = Infinity;\n        let minArea = Infinity;\n\n        for (let i = m; i <= M - m; i++) {\n            const bbox1 = distBBox(node, 0, i, this.toBBox);\n            const bbox2 = distBBox(node, i, M, this.toBBox);\n\n            const overlap = intersectionArea(bbox1, bbox2);\n            const area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index || M - m;\n    }\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis(node, m, M) {\n        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n        const xMargin = this._allDistMargin(node, m, M, compareMinX);\n        const yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    }\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin(node, m, M, compare) {\n        node.children.sort(compare);\n\n        const toBBox = this.toBBox;\n        const leftBBox = distBBox(node, 0, m, toBBox);\n        const rightBBox = distBBox(node, M - m, M, toBBox);\n        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n        for (let i = m; i < M - m; i++) {\n            const child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (let i = M - m - 1; i >= m; i--) {\n            const child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    }\n\n    _adjustParentBBoxes(bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (let i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    }\n\n    _condense(path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (let i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    }\n}\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (let i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (let i = k; i < p; i++) {\n        const child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    const minX = Math.max(a.minX, b.minX);\n    const minY = Math.max(a.minY, b.minY);\n    const maxX = Math.min(a.maxX, b.maxX);\n    const maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    const stack = [left, right];\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        const mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","\nexport default class TinyQueue {\n    constructor(data = [], compare = defaultCompare) {\n        this.data = data;\n        this.length = this.data.length;\n        this.compare = compare;\n\n        if (this.length > 0) {\n            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n        }\n    }\n\n    push(item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    }\n\n    pop() {\n        if (this.length === 0) return undefined;\n\n        const top = this.data[0];\n        const bottom = this.data.pop();\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = bottom;\n            this._down(0);\n        }\n\n        return top;\n    }\n\n    peek() {\n        return this.data[0];\n    }\n\n    _up(pos) {\n        const {data, compare} = this;\n        const item = data[pos];\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    }\n\n    _down(pos) {\n        const {data, compare} = this;\n        const halfLength = this.length >> 1;\n        const item = data[pos];\n\n        while (pos < halfLength) {\n            let left = (pos << 1) + 1;\n            let best = data[left];\n            const right = left + 1;\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","var pointInPolygonFlat = require('./flat.js')\nvar pointInPolygonNested = require('./nested.js')\n\nmodule.exports = function pointInPolygon (point, vs, start, end) {\n    if (vs.length > 0 && Array.isArray(vs[0])) {\n        return pointInPolygonNested(point, vs, start, end);\n    } else {\n        return pointInPolygonFlat(point, vs, start, end);\n    }\n}\nmodule.exports.nested = pointInPolygonNested\nmodule.exports.flat = pointInPolygonFlat\n","module.exports = function pointInPolygonFlat (point, vs, start, end) {\n    var x = point[0], y = point[1];\n    var inside = false;\n    if (start === undefined) start = 0;\n    if (end === undefined) end = vs.length;\n    var len = (end-start)/2;\n    for (var i = 0, j = len - 1; i < len; j = i++) {\n        var xi = vs[start+i*2+0], yi = vs[start+i*2+1];\n        var xj = vs[start+j*2+0], yj = vs[start+j*2+1];\n        var intersect = ((yi > y) !== (yj > y))\n            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n        if (intersect) inside = !inside;\n    }\n    return inside;\n};\n","// ray-casting algorithm based on\n// https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html\n\nmodule.exports = function pointInPolygonNested (point, vs, start, end) {\n    var x = point[0], y = point[1];\n    var inside = false;\n    if (start === undefined) start = 0;\n    if (end === undefined) end = vs.length;\n    var len = end - start;\n    for (var i = 0, j = len - 1; i < len; j = i++) {\n        var xi = vs[i+start][0], yi = vs[i+start][1];\n        var xj = vs[j+start][0], yj = vs[j+start][1];\n        var intersect = ((yi > y) !== (yj > y))\n            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n        if (intersect) inside = !inside;\n    }\n    return inside;\n};\n","export const epsilon = 1.1102230246251565e-16;\nexport const splitter = 134217729;\nexport const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n// fast_expansion_sum_zeroelim routine from oritinal code\nexport function sum(elen, e, flen, f, h) {\n    let Q, Qnew, hh, bvirt;\n    let enow = e[0];\n    let fnow = f[0];\n    let eindex = 0;\n    let findex = 0;\n    if ((fnow > enow) === (fnow > -enow)) {\n        Q = enow;\n        enow = e[++eindex];\n    } else {\n        Q = fnow;\n        fnow = f[++findex];\n    }\n    let hindex = 0;\n    if (eindex < elen && findex < flen) {\n        if ((fnow > enow) === (fnow > -enow)) {\n            Qnew = enow + Q;\n            hh = Q - (Qnew - enow);\n            enow = e[++eindex];\n        } else {\n            Qnew = fnow + Q;\n            hh = Q - (Qnew - fnow);\n            fnow = f[++findex];\n        }\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        while (eindex < elen && findex < flen) {\n            if ((fnow > enow) === (fnow > -enow)) {\n                Qnew = Q + enow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (enow - bvirt);\n                enow = e[++eindex];\n            } else {\n                Qnew = Q + fnow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n                fnow = f[++findex];\n            }\n            Q = Qnew;\n            if (hh !== 0) {\n                h[hindex++] = hh;\n            }\n        }\n    }\n    while (eindex < elen) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    while (findex < flen) {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function sum_three(alen, a, blen, b, clen, c, tmp, out) {\n    return sum(sum(alen, a, blen, b, tmp), tmp, clen, c, out);\n}\n\n// scale_expansion_zeroelim routine from oritinal code\nexport function scale(elen, e, b, h) {\n    let Q, sum, hh, product1, product0;\n    let bvirt, c, ahi, alo, bhi, blo;\n\n    c = splitter * b;\n    bhi = c - (c - b);\n    blo = b - bhi;\n    let enow = e[0];\n    Q = enow * b;\n    c = splitter * enow;\n    ahi = c - (c - enow);\n    alo = enow - ahi;\n    hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);\n    let hindex = 0;\n    if (hh !== 0) {\n        h[hindex++] = hh;\n    }\n    for (let i = 1; i < elen; i++) {\n        enow = e[i];\n        product1 = enow * b;\n        c = splitter * enow;\n        ahi = c - (c - enow);\n        alo = enow - ahi;\n        product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);\n        sum = Q + product0;\n        bvirt = sum - Q;\n        hh = Q - (sum - bvirt) + (product0 - bvirt);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        Q = product1 + sum;\n        hh = sum - (Q - product1);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function negate(elen, e) {\n    for (let i = 0; i < elen; i++) e[i] = -e[i];\n    return elen;\n}\n\nexport function estimate(elen, e) {\n    let Q = e[0];\n    for (let i = 1; i < elen; i++) Q += e[i];\n    return Q;\n}\n\nexport function vec(n) {\n    return new Float64Array(n);\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum} from './util.js';\n\nconst ccwerrboundA = (3 + 16 * epsilon) * epsilon;\nconst ccwerrboundB = (2 + 12 * epsilon) * epsilon;\nconst ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n\nconst B = vec(4);\nconst C1 = vec(8);\nconst C2 = vec(12);\nconst D = vec(16);\nconst u = vec(4);\n\nfunction orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n    let acxtail, acytail, bcxtail, bcytail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    const acx = ax - cx;\n    const bcx = bx - cx;\n    const acy = ay - cy;\n    const bcy = by - cy;\n\n    s1 = acx * bcy;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcx;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    B[3] = u3;\n\n    let det = estimate(4, B);\n    let errbound = ccwerrboundB * detsum;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - acx;\n    acxtail = ax - (acx + bvirt) + (bvirt - cx);\n    bvirt = bx - bcx;\n    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n    bvirt = ay - acy;\n    acytail = ay - (acy + bvirt) + (bvirt - cy);\n    bvirt = by - bcy;\n    bcytail = by - (bcy + bvirt) + (bvirt - cy);\n\n    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n        return det;\n    }\n\n    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\n    if (det >= errbound || -det >= errbound) return det;\n\n    s1 = acxtail * bcy;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcx;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C1len = sum(4, B, 4, u, C1);\n\n    s1 = acx * bcytail;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcxtail;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C2len = sum(C1len, C1, 4, u, C2);\n\n    s1 = acxtail * bcytail;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcxtail;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const Dlen = sum(C2len, C2, 4, u, D);\n\n    return D[Dlen - 1];\n}\n\nexport function orient2d(ax, ay, bx, by, cx, cy) {\n    const detleft = (ay - cy) * (bx - cx);\n    const detright = (ax - cx) * (by - cy);\n    const det = detleft - detright;\n\n    const detsum = Math.abs(detleft + detright);\n    if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n\n    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n}\n\nexport function orient2dfast(ax, ay, bx, by, cx, cy) {\n    return (ay - cy) * (bx - cx) - (ax - cx) * (by - cy);\n}\n","import RBush from \"rbush\";\nimport Queue from \"tinyqueue\";\nimport pointInPolygon from \"point-in-polygon\";\nimport { orient2d as orient } from \"robust-predicates\";\n\nexport function concaveman(points, concavity, lengthThreshold) {\n  // a relative measure of concavity; higher value means simpler hull\n  concavity = Math.max(0, concavity === undefined ? 2 : concavity);\n\n  // when a segment goes below this length threshold, it won't be drilled down further\n  lengthThreshold = lengthThreshold || 0;\n\n  // start with a convex hull of the points\n  var hull = fastConvexHull(points);\n\n  // index the points with an R-tree\n  var tree = new RBush(16);\n  tree.toBBox = function (a) {\n    return {\n      minX: a[0],\n      minY: a[1],\n      maxX: a[0],\n      maxY: a[1],\n    };\n  };\n  tree.compareMinX = function (a, b) {\n    return a[0] - b[0];\n  };\n  tree.compareMinY = function (a, b) {\n    return a[1] - b[1];\n  };\n\n  tree.load(points);\n\n  // turn the convex hull into a linked list and populate the initial edge queue with the nodes\n  var queue = [];\n  for (var i = 0, last; i < hull.length; i++) {\n    var p = hull[i];\n    tree.remove(p);\n    last = insertNode(p, last);\n    queue.push(last);\n  }\n\n  // index the segments with an R-tree (for intersection checks)\n  var segTree = new RBush(16);\n  for (i = 0; i < queue.length; i++) segTree.insert(updateBBox(queue[i]));\n\n  var sqConcavity = concavity * concavity;\n  var sqLenThreshold = lengthThreshold * lengthThreshold;\n\n  // process edges one by one\n  while (queue.length) {\n    var node = queue.shift();\n    var a = node.p;\n    var b = node.next.p;\n\n    // skip the edge if it's already short enough\n    var sqLen = getSqDist(a, b);\n    if (sqLen < sqLenThreshold) continue;\n\n    var maxSqLen = sqLen / sqConcavity;\n\n    // find the best connection point for the current edge to flex inward to\n    p = findCandidate(\n      tree,\n      node.prev.p,\n      a,\n      b,\n      node.next.next.p,\n      maxSqLen,\n      segTree\n    );\n\n    // if we found a connection and it satisfies our concavity measure\n    if (p && Math.min(getSqDist(p, a), getSqDist(p, b)) <= maxSqLen) {\n      // connect the edge endpoints through this point and add 2 new edges to the queue\n      queue.push(node);\n      queue.push(insertNode(p, node));\n\n      // update point and segment indexes\n      tree.remove(p);\n      segTree.remove(node);\n      segTree.insert(updateBBox(node));\n      segTree.insert(updateBBox(node.next));\n    }\n  }\n\n  // convert the resulting hull linked list to an array of points\n  node = last;\n  var concave = [];\n  do {\n    concave.push(node.p);\n    node = node.next;\n  } while (node !== last);\n\n  concave.push(node.p);\n\n  return concave;\n}\n\nfunction findCandidate(tree, a, b, c, d, maxDist, segTree) {\n  var queue = new Queue([], compareDist);\n  var node = tree.data;\n\n  // search through the point R-tree with a depth-first search using a priority queue\n  // in the order of distance to the edge (b, c)\n  while (node) {\n    for (var i = 0; i < node.children.length; i++) {\n      var child = node.children[i];\n\n      var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);\n      if (dist > maxDist) continue; // skip the node if it's farther than we ever need\n\n      queue.push({\n        node: child,\n        dist: dist,\n      });\n    }\n\n    while (queue.length && !queue.peek().node.children) {\n      var item = queue.pop();\n      var p = item.node;\n\n      // skip all points that are as close to adjacent edges (a,b) and (c,d),\n      // and points that would introduce self-intersections when connected\n      var d0 = sqSegDist(p, a, b);\n      var d1 = sqSegDist(p, c, d);\n      if (\n        item.dist < d0 &&\n        item.dist < d1 &&\n        noIntersections(b, p, segTree) &&\n        noIntersections(c, p, segTree)\n      )\n        return p;\n    }\n\n    node = queue.pop();\n    if (node) node = node.node;\n  }\n\n  return null;\n}\n\nfunction compareDist(a, b) {\n  return a.dist - b.dist;\n}\n\n// square distance from a segment bounding box to the given one\nfunction sqSegBoxDist(a, b, bbox) {\n  if (inside(a, bbox) || inside(b, bbox)) return 0;\n  var d1 = sqSegSegDist(\n    a[0],\n    a[1],\n    b[0],\n    b[1],\n    bbox.minX,\n    bbox.minY,\n    bbox.maxX,\n    bbox.minY\n  );\n  if (d1 === 0) return 0;\n  var d2 = sqSegSegDist(\n    a[0],\n    a[1],\n    b[0],\n    b[1],\n    bbox.minX,\n    bbox.minY,\n    bbox.minX,\n    bbox.maxY\n  );\n  if (d2 === 0) return 0;\n  var d3 = sqSegSegDist(\n    a[0],\n    a[1],\n    b[0],\n    b[1],\n    bbox.maxX,\n    bbox.minY,\n    bbox.maxX,\n    bbox.maxY\n  );\n  if (d3 === 0) return 0;\n  var d4 = sqSegSegDist(\n    a[0],\n    a[1],\n    b[0],\n    b[1],\n    bbox.minX,\n    bbox.maxY,\n    bbox.maxX,\n    bbox.maxY\n  );\n  if (d4 === 0) return 0;\n  return Math.min(d1, d2, d3, d4);\n}\n\nfunction inside(a, bbox) {\n  return (\n    a[0] >= bbox.minX &&\n    a[0] <= bbox.maxX &&\n    a[1] >= bbox.minY &&\n    a[1] <= bbox.maxY\n  );\n}\n\n// check if the edge (a,b) doesn't intersect any other edges\nfunction noIntersections(a, b, segTree) {\n  var minX = Math.min(a[0], b[0]);\n  var minY = Math.min(a[1], b[1]);\n  var maxX = Math.max(a[0], b[0]);\n  var maxY = Math.max(a[1], b[1]);\n\n  var edges = segTree.search({\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY,\n  });\n  for (var i = 0; i < edges.length; i++) {\n    if (intersects(edges[i].p, edges[i].next.p, a, b)) return false;\n  }\n  return true;\n}\n\nfunction cross(p1, p2, p3) {\n  return orient(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);\n}\n\n// check if the edges (p1,q1) and (p2,q2) intersect\nfunction intersects(p1, q1, p2, q2) {\n  return (\n    p1 !== q2 &&\n    q1 !== p2 &&\n    cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 &&\n    cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0\n  );\n}\n\n// update the bounding box of a node's edge\nfunction updateBBox(node) {\n  var p1 = node.p;\n  var p2 = node.next.p;\n  node.minX = Math.min(p1[0], p2[0]);\n  node.minY = Math.min(p1[1], p2[1]);\n  node.maxX = Math.max(p1[0], p2[0]);\n  node.maxY = Math.max(p1[1], p2[1]);\n  return node;\n}\n\n// speed up convex hull by filtering out points inside quadrilateral formed by 4 extreme points\nfunction fastConvexHull(points) {\n  var left = points[0];\n  var top = points[0];\n  var right = points[0];\n  var bottom = points[0];\n\n  // find the leftmost, rightmost, topmost and bottommost points\n  for (var i = 0; i < points.length; i++) {\n    var p = points[i];\n    if (p[0] < left[0]) left = p;\n    if (p[0] > right[0]) right = p;\n    if (p[1] < top[1]) top = p;\n    if (p[1] > bottom[1]) bottom = p;\n  }\n\n  // filter out points that are inside the resulting quadrilateral\n  var cull = [left, top, right, bottom];\n  var filtered = cull.slice();\n  for (i = 0; i < points.length; i++) {\n    if (!pointInPolygon(points[i], cull)) filtered.push(points[i]);\n  }\n\n  // get convex hull around the filtered points\n  return convexHull(filtered);\n}\n\n// create a new node in a doubly linked list\nfunction insertNode(p, prev) {\n  var node = {\n    p: p,\n    prev: null,\n    next: null,\n    minX: 0,\n    minY: 0,\n    maxX: 0,\n    maxY: 0,\n  };\n\n  if (!prev) {\n    node.prev = node;\n    node.next = node;\n  } else {\n    node.next = prev.next;\n    node.prev = prev;\n    prev.next.prev = node;\n    prev.next = node;\n  }\n  return node;\n}\n\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n  var dx = p1[0] - p2[0],\n    dy = p1[1] - p2[1];\n\n  return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction sqSegDist(p, p1, p2) {\n  var x = p1[0],\n    y = p1[1],\n    dx = p2[0] - x,\n    dy = p2[1] - y;\n\n  if (dx !== 0 || dy !== 0) {\n    var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n\n    if (t > 1) {\n      x = p2[0];\n      y = p2[1];\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n\n  dx = p[0] - x;\n  dy = p[1] - y;\n\n  return dx * dx + dy * dy;\n}\n\n// segment to segment distance, ported from http://geomalgorithms.com/a07-_distance.html by Dan Sunday\nfunction sqSegSegDist(x0, y0, x1, y1, x2, y2, x3, y3) {\n  var ux = x1 - x0;\n  var uy = y1 - y0;\n  var vx = x3 - x2;\n  var vy = y3 - y2;\n  var wx = x0 - x2;\n  var wy = y0 - y2;\n  var a = ux * ux + uy * uy;\n  var b = ux * vx + uy * vy;\n  var c = vx * vx + vy * vy;\n  var d = ux * wx + uy * wy;\n  var e = vx * wx + vy * wy;\n  var D = a * c - b * b;\n\n  var sc, sN, tc, tN;\n  var sD = D;\n  var tD = D;\n\n  if (D === 0) {\n    sN = 0;\n    sD = 1;\n    tN = e;\n    tD = c;\n  } else {\n    sN = b * e - c * d;\n    tN = a * e - b * d;\n    if (sN < 0) {\n      sN = 0;\n      tN = e;\n      tD = c;\n    } else if (sN > sD) {\n      sN = sD;\n      tN = e + b;\n      tD = c;\n    }\n  }\n\n  if (tN < 0.0) {\n    tN = 0.0;\n    if (-d < 0.0) sN = 0.0;\n    else if (-d > a) sN = sD;\n    else {\n      sN = -d;\n      sD = a;\n    }\n  } else if (tN > tD) {\n    tN = tD;\n    if (-d + b < 0.0) sN = 0;\n    else if (-d + b > a) sN = sD;\n    else {\n      sN = -d + b;\n      sD = a;\n    }\n  }\n\n  sc = sN === 0 ? 0 : sN / sD;\n  tc = tN === 0 ? 0 : tN / tD;\n\n  var cx = (1 - sc) * x0 + sc * x1;\n  var cy = (1 - sc) * y0 + sc * y1;\n  var cx2 = (1 - tc) * x2 + tc * x3;\n  var cy2 = (1 - tc) * y2 + tc * y3;\n  var dx = cx2 - cx;\n  var dy = cy2 - cy;\n\n  return dx * dx + dy * dy;\n}\n\nfunction compareByX(a, b) {\n  return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];\n}\n\nfunction convexHull(points) {\n  points.sort(compareByX);\n\n  var lower = [];\n  for (var i = 0; i < points.length; i++) {\n    while (\n      lower.length >= 2 &&\n      cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0\n    ) {\n      lower.pop();\n    }\n    lower.push(points[i]);\n  }\n\n  var upper = [];\n  for (var ii = points.length - 1; ii >= 0; ii--) {\n    while (\n      upper.length >= 2 &&\n      cross(upper[upper.length - 2], upper[upper.length - 1], points[ii]) <= 0\n    ) {\n      upper.pop();\n    }\n    upper.push(points[ii]);\n  }\n\n  upper.pop();\n  lower.pop();\n  return lower.concat(upper);\n}\n"],"names":["quickselect","arr","k","left","right","compare","quickselectStep","length","defaultCompare","n","m","z","Math","log","s","exp","sd","sqrt","max","floor","min","t","i","j","swap","tmp","a","b","RBush","constructor","maxEntries","this","_maxEntries","_minEntries","ceil","clear","all","_all","data","search","bbox","node","result","intersects","toBBox","nodesToSearch","children","child","childBBox","leaf","push","contains","pop","collides","load","insert","_build","slice","height","_splitRoot","tmpNode","_insert","item","createNode","remove","equalsFn","path","indexes","parent","goingUp","index","findItem","splice","_condense","compareMinX","minX","compareMinY","minY","toJSON","fromJSON","items","N","M","calcBBox","pow","N2","N1","multiSelect","right2","right3","_chooseSubtree","level","targetNode","minArea","Infinity","minEnlargement","area","bboxArea","enlargement","maxX","maxY","isNode","insertPath","extend","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","minOverlap","bbox1","distBBox","bbox2","overlap","intersectionArea","compareNodeMinX","compareNodeMinY","_allDistMargin","sort","leftBBox","rightBBox","margin","bboxMargin","siblings","indexOf","p","destNode","stack","mid","TinyQueue","_down","_up","top","bottom","peek","pos","current","halfLength","best","pointInPolygonFlat","point","vs","start","end","x","y","inside","undefined","len","xi","yi","xj","yj","pointInPolygonNested","pointInPolygonModule","exports","Array","isArray","nested","flat","epsilon","splitter","resulterrbound","sum","elen","e","flen","f","h","Q","Qnew","hh","bvirt","enow","fnow","eindex","findex","hindex","vec","Float64Array","ccwerrboundA","ccwerrboundB","ccwerrboundC","B","C1","C2","D","u","findCandidate","tree","c","d","maxDist","segTree","queue","Queue","compareDist","dist","sqSegDist","sqSegBoxDist","d0","d1","noIntersections","sqSegSegDist","d2","d3","d4","p1","q1","p2","q2","edges","next","cross","p3","ax","ay","bx","by","cx","cy","detleft","detright","det","detsum","abs","acxtail","acytail","bcxtail","bcytail","ahi","alo","bhi","blo","_i","_j","_0","s1","s0","t1","t0","u3","acx","bcx","acy","bcy","estimate","errbound","C1len","C2len","Dlen","orient2dadapt","orient","updateBBox","insertNode","prev","getSqDist","dx","dy","x0","y0","x1","y1","x2","y2","x3","y3","sc","sN","tc","tN","ux","uy","vx","vy","wx","wy","sD","tD","compareByX","points","concavity","lengthThreshold","hull","cull","filtered","pointInPolygon","lower","upper","ii","concat","convexHull","fastConvexHull","last","sqConcavity","sqLenThreshold","shift","sqLen","maxSqLen","concave"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7]}